Avoiding vehicle symmetry
	We assume that the number of requests is the same or greater than the number of cars, if this isn't true, the number of cars can be reduced to the number of requests before the beggining of the algorthm without affecting any optimal solutions.
	If a partial solution have at least two empty cars (c1 and c2), then one branch can assign car c1 the requests r1 and r2, and another brach can assign car c2 the requests r1 and r2, therefore making two symmetrical equal (possibly partial) solutions (all other vehicles, if any, have the same routes, and there is one vehicle with an empty route and another with requests r1 and r2, which vehicle has which route does not matter, as the homogeneous vehicles should be treated as a set).
	If a partial solution s have at most one empty car, then no two descendants of that solution can be symmetrically equivalent. The proof follows: the first generation of descendants of s will include one single extra request, and there will be at most n*v of them (at most any route can be choosen to be incremented, and any route choosen can be incremented by any request, this is a very weakly constrained instance). Let us say the incremented route is R_1+r_1 PROBLEM even if there's no empty cars, we can add r1 first r2 second, or r2 first r1 second, to the same route, ending up with symmetrical solutions, 
	ok, what if we keep a index in each route indicating the smallest request served to it, and only allow adding requests smaller than them? no x requests can be assigned to the same route in different orders, only in decreasing order
	also, to avoid recomputation, the only way is to expand all non-dominated and valid PD sequence when adding a new request to a route/vehicle

// V is the unsigned integer type used for vehicles
// R is the unsigned integer type used for requests
// L is the signed integer type used for locations // this way positive and negative are used for pickups and deliveries of the associated request
// Requests and locations types could be conflated in one, but will not to avoid propaging semantic errors.

template <typename V, typename R, typename L>
struct state_t {
	std::vector< std::(forward_)list< L > /* dynamic size, max qt_requests */ > routes; /* size qt_vehicles */
	// maybe the list will be custom to reuse list parts between states
	// another little optimization, in fact, would be expanding all states but one and then transforming the current state in the last expansion
	std::vector< R > last_req_added; // to serve as limit for the expansion for
};

idea of search algorithm, as a DP but with everything lazy (not exactly lazy, but in fact a stack that keeps the state and allows to only consider one state a time, while the other states that should have been expanded are waiting to be expanded in the future)

The requests are ordered in a heuristic order (not relevant for the algorithm to be exact, not sure what to use now, do tests with many possibilities in the future). The requests are added one by one in the solution. When a request is added there's two consecutive branchs: which route/vehicle will take care of it; where pickup and delivery will be in the route. The first branch occurs between all distinct route options. Consequently, in an empty partial solution (with an empty route for each vehicle) there's only one option: the empty route. After the first request was inserted there's two options: the route with the first request and the empty route. In the insertion of the second request into the route with the first request, the second branch occurs. A new state is generated for each PROBLEM even if we consider only the available distinct routes and add the requests in a specific order there can happen the following case: after adding r1 and r2 to a route (specific state), it branches many times (many requests are added), and when r9 will be added, there's many branchs with the route r1+r2 that will have a state expansion adding r9 to them, and will end up computing many times the best way to route that requests in different contexts that does not matter (the way to add request r to a route x minimizing route size for the time/cost does not change because which requests are in the other routes and how PD's are ordered in the other routes).

heuristic minimize travel cost to attend subset of the requests weighting for difficulty to attend a request

Doubt: if the minimum cost route containing only requests r1 and r2 is a sequence of PDs s1 (for now assuming only one minimum cost route, not many), and the minimum cost route containing only requests r1, r2 and r3 is a sequence of PDs s2, how common are inversions between the PDs of r1 and r2 in s1 to s2? they happen at all? if they happen they are frequent or infrequent? they only happen in some conditions?
	If inversions never occurred, then to add a new request in a route keeping its optimality would need only to check O(stops^2) possibilities (if the pickup can be added to every slot, and the delivery to every slot after the pickup). Each possibility could need O(stops) steps, but this would end in O(stops^3) steps, probably amortized O(stops^2) if well done. However, the single-vehicle DARP being NP complete probably guarantees that this is not possible.
	If inversions occur in general, but rarely, exact algorithms will have a hard time, and starting with small routes and growing them in bigger ones request by request (with interleaved optimizations) will probably waste computational effort. This would be a good justificative for heuristic insertions working well if each vehicle is assigned to take care of the "right" group of requests (this can be harder if there's no pattern, but if there are as many spatial request clusters as vehicles, the heuristic answer can be correct).
	If inversions occur in some specific cases only, we can shave some effort by detecting such characteristics (if they are easily detectable), and maybe make some lower bounds of it.
	If inversion occur often in the general case, ..., it is problematic. To the problem to be easy the cars would need to take care of few requests each (because the exponential number of combinations in a route). The routing problen would need advanced algorithms for it only (to guarantee not all states are checked). The focus would need to find the most promising clusters of vehicles to be served by the same route first, and use a efficient set packing algorithm to find the optimal solution needing to evaluate the smallest number of requests subsets as possible (each subset consideration would need to compute the best route of that subset, if existing). Finding good upper/lower bounds and (un)feasibility proofs for the routing of requests subsets would be important, as the most promising could be optimally solved first, and then the rest would be excluded because their lower bounds guarantee that using that subset to fit the hole will not be optimal.

Doubts: the request distances in the real world follow a (normal) distribution? the common way of generating the requests (two random points in a square) makes the distance follow a distribution? which one? they are different (real world and common artificial)?

The first order objective is to try to devise a state expansion algorithm which only visits each state one time (in the UKP this was possible, each different solution was created a single time, and was queried one time to generate all descendant solutions). The second order objective is to minimize the processing of a node and the number of states it expands to (without giving up on optimality).

Adding the requests in a specific order to all distinct route options do only visit each "complete state" a single time, however as already thought before: the same subset of requests forming a single route is visited many many times; but the things external to a single route (i.e., the other routes) can be different (what changes basically nothing for the route in question). This can be fixed by going back to using a maximal allowed index in each route (implementation idea: the requests are in a double linked list, the maximal allowed index is a pointer to a node, when adding a request to a route, change the maximal allowed index to the neighbor node of the addeds request node, remove the added node from the list) AND 

The best idea still seems to create a iterator between all set partitions of size K, which begins biased to sets that are present in good/optimal solutions (sets of close points?), computes the best route of each set, and reuses as many computation as possible ... maybe starting with a feasible solution of the depth-first paper, and then using move request operations between routes, but again this would depend on how the whole route needs to be recomputed by removing a request from it or adding a request to it. So it's another argument to make tests checking this.

DOUBT: there's an algorithm that allows to start from an arbitrary partition and then iterate all partitions of set S with max K partitions, allowing for easily jumbing all partitions with some characteristic?

Solved doubt: there's obviously no o(n^2) check for which sets of requests are compatible to each other, as the result is a n^2 matrix.

The idea of partial solutions is that if an incomplete state is unfeasible, then much can be cut (i.e., all states descended from it), however, this also makes DP to focus on being faster for very restricted problems, adding a good solution heuristic at beggining and cutting with base in it would help too, but creates a whole new class of problems of configuring the heuristic correctly for different types of instances (and dealing with the possibility of not finding a feasible solution). 
A good lower bound in a route size seems problematic (even not considering feasibility): theorically, the points of the first request can define a line segment, and all the remaining requests have points in this segment. With the pair routes pre-computed, a max{all optimal pairs plus the service times of the rest} is weak and is already not linear on route size.

Each set of 

